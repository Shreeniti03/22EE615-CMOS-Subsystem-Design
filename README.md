<h1># 22EE615-CMOS-Subsystem-Design</h1>

This repository contains the Verilog Code and Testbench of different types of adders.
Adders are digital circuits that perform arithmetic addition operations. They are a fundamental component of digital systems, used in various applications such as computers, calculators, and embedded systems.

<h2># Content [ADDERS]:</h2>

**1. <i>4-Bit Carry Propagate Adder</i>**
  Basic adder that propagates carry from one bit to the next.
  
  **Operation:**
1. Initial Step: Each FA adds the corresponding bits of the two input numbers (A and B) and produces a sum and carry.
2. Carry Propagation: The carry output from each FA is propagated to the next FA.
3. Final Sum Generation: The final sum is generated by combining the sum outputs from each FA.
4. Final Carry Generation: The final carry output is generated by the last FA.

   # Waveform:
   ![Screenshot_(277) 1](https://github.com/user-attachments/assets/76d51edc-46d8-43c6-b962-c4918cb228aa)
   
   # Schematic:
   ![Screenshot_(278) 2](https://github.com/user-attachments/assets/6201b1a6-f967-4507-b122-3541ed7c9c9f)

**2. <i>8-Bit Carry Look-Ahead Adder</i>** 
  A Carry Look-Ahead Adder (CLA) is a digital circuit that uses a separate carry generation network to predict and generate carries in advance, reducing propagation delay and increasing speed.
  
  **Operation:**
1. Initial Step: Each FA adds the corresponding bits of the two input numbers (A and B) and produces a sum and carry.
2. Carry Look-Ahead Logic: The carry look-ahead logic generates the carry output for each FA based on the input bits A and B.
3. Final Sum Generation: The final sum is generated by combining the sum outputs from each FA.
4. Final Carry Generation: The final carry output is generated by the carry look-ahead logic.
  
   # Waveform:
   ![Screenshot_(280) 1](https://github.com/user-attachments/assets/280fe4c8-0cd1-4851-9608-7967acdb1258)

   # Schematic:
   ![Screenshot_(281) 1](https://github.com/user-attachments/assets/60380ea3-a6e3-4abc-9a90-ea3295a39aa4)

**3. <i>8-Bit Carry Save Adder ( Multi Operand)</i>**
  Adder that saves carry bits instead of propagating them.

  **Operation:**
1. Initial Step: Each FA adds the corresponding bits of the two input numbers (A and B) and produces a sum and carry.
2. Carry Save Logic: The carry save logic blocks save the carry output from each FA. The saved carries are then added to the sum outputs from each FA.
3. Final Sum Generation: The final sum is generated by combining the sum outputs from each FA and the saved carries.
4. Final Carry Generation: The final carry output is generated by combining the carry outputs from each FA.
   
   # Waveform:
   ![Screenshot_(282) 1](https://github.com/user-attachments/assets/4b519779-1957-486d-9208-8da2c1066017)

   # Schematic:
   ![Screenshot_(283) 1](https://github.com/user-attachments/assets/30ed8aa1-1cf9-4510-a6d7-a7c38ce24111)

**4. <i>8-Bit Carry Bypass ( Skip ) Adder</i>** 
  Adder that bypasses carry propagation for certain bits.
  
   **Operation:**
1. Initial Step: Each FA adds the corresponding bits of the two input numbers (A and B) and produces a sum and carry.
2. Bypass Logic: The bypass logic blocks check the carry output from each FA. If the carry is 0, the bypass logic sets the carry input to the next FA to 0. If the carry is 1, the bypass logic sets the carry input to the next FA to 1.
3. Final Sum Generation: The final sum is generated by combining the sum outputs from each FA.
4. Final Carry Generation: The final carry output is generated by combining the carry outputs from each FA.

   # Waveform:
   ![Screenshot_(284) 1](https://github.com/user-attachments/assets/92416c29-6bce-43e3-99b6-7cf3344c119a)

   # Schematic:
   ![Screenshot_(285) 2](https://github.com/user-attachments/assets/08c47fa5-f34e-4e3e-9b01-6b366bfed628)

**5. <i>8-Bit Conditional Sum Adder</i>** 
  Adder that computes two possible sums and selects the correct one based on the carry.
  
   **Operation:**
1. Initial Step: Each FA adds the corresponding bits of the two input numbers (A and B) and produces a sum and carry.
2. Conditional Sum Generation: Each MUX selects between the sum generated by the FA and the sum generated by the FA with the carry input set to 1. The selection is based on the carry input.
3. Final Carry Generation: The carry generation circuit produces the final carry output based on the carries generated by each FA.
4. Final Sum Generation: The final sum is generated by selecting the correct sum from each MUX based on the final carry output.

    # Waveform:
   ![Screenshot_(286) 1](https://github.com/user-attachments/assets/f7e5010e-d7ff-4b5c-a029-8efe16f20931)

   # Schematic:
   ![Screenshot_(287) 1](https://github.com/user-attachments/assets/ec2ec26c-7b8d-4fe2-88a3-211d93eb0f3e)



   
